# 실시간 매칭 시스템 설계 제안서 (v4)

## 1. 개요 (Introduction)

본 문서는 사용자의 취미, 지역, 나이 및 정교한 점수 체계를 기반으로 하는 실시간 매칭 시스템의 아키텍처 설계를 목적으로 한다. 기존의 단순 조회 방식을 탈피하여, **PostgreSQL의 동시성 제어 기능과
GIN 인덱스를 적극 활용**한 하이브리드 매칭 방식을 도입하여 고성능과 데이터 무결성을 보장하는 시스템을 구축한다.

### 1.1. 핵심 목표 (Key Goals)

* **초저지연 매칭 (Low-Latency Matching)**: 대기자가 존재할 경우, API 요청 시점에서 **0.1초 내 즉시 매칭**을 목표로 한다. (Controller Intercept)
* **높은 동시성 처리 (High Concurrency)**: `SELECT ... FOR UPDATE SKIP LOCKED`를 적용하여 여러 스케줄러와 API 서버가 동시에 실행되어도 **중복 매칭(Double
  Booking) 문제를 원천 차단**한다.
* **최적화된 성능 (Optimized Performance)**: PostgreSQL의 **GIN 인덱스**를 사용하여 배열(Array) 기반의 다중 취미 조건 검색 속도를 극대화한다.
* **향상된 사용자 경험 (Better UX)**: Polling 방식 대신 **Supabase Realtime**을 활용하여 매칭 성사 시 클라이언트에 즉시 시그널을 전송한다.

## 2. 핵심 기능 요구사항

### 2.1. 단계별 매칭 조건

매칭 성공률을 높이기 위해, 사용자의 대기 시간에 따라 조건을 5단계에 걸쳐 점진적으로 완화한다.

| 단계  | 대기 시간  | 완화 조건 (AND 연산)                  | 거름 회원 매칭 여부 |
|:----|:-------|:--------------------------------|:------------|
| 1단계 | 0~5초   | **취미 교집합** + 지역 + 나이(±5) + 이성   | 불가          |
| 2단계 | 5~10초  | [취미 무관] + 지역 + 나이(±5) + 이성      | 불가          |
| 3단계 | 10~20초 | [취미 무관] + [지역 무관] + 나이(±5) + 이성 | 불가          |
| 4단계 | 20~30초 | [취미/지역 무관] + [나이 무관] + 이성       | 불가          |
| 5단계 | 30초 이상 | **[모든 조건 무관]** + 동성 허용          | **허용 (구제)** |

### 2.2. 사용자 점수 및 등급 시스템

사용자의 활동을 정량적으로 평가하여 5단계의 등급(Tier)으로 관리하며, 이는 매칭 품질과 직접적으로 연관된다.

* **등급 체계**: 열매(21점~), 꽃잎(11~20점), 새싹(-10~10점), 시들(-20~-11점), 거름(~-21점)
* **핵심 정책**: **거름 회원(-21점 이하)**은 1~4단계 매칭에서 제외하여 서비스 품질을 유지하고, 5단계에서만 제한적으로 매칭을 허용한다.
* **점수 업데이트**: 점수 변경은 실시간 매칭 로직과 분리하여, 별도의 비동기 이벤트 기반으로 처리한다. (신고, 대화 시간, 접속 등)

## 3. 제안 아키텍처: PostgreSQL 중심 하이브리드 모델

### 3.1. 아키텍처 흐름도

```
[Client] <--Supabase Realtime-- [API Server (Spring Boot)] <--> [Database (PostgreSQL)]
   |         (Matched Event)             |                         ^
   |                                     |                         |
   |--(1) Match Request (POST /match)--> | --(2a) Intercept Logic--|
   |                                     |                         |
   |                                     | --(2b) Enqueue Logic----|
   |                                     |                         |
   └-------------------------------------| --(3) Scheduler Logic---|
```

### 3.2. 구성 요소

1. **API 서버 (Spring Boot)**
    * **즉시 매칭 (Intercept)**: `/match` 요청 수신 시, 대기열에 자신을 넣기 전에 먼저 조건에 맞는 상대가 있는지 탐색하여 즉시 매칭을 시도한다.
    * **대기열 추가 (Enqueue)**: 즉시 매칭에 실패할 경우, 자신의 정보를 `match_queue` 테이블에 `INSERT`한다.
2. **스케줄러 (Spring Boot `@Scheduled`)**
    * **주기적 매칭 (Loop)**: 1초 주기로 실행되며, `match_queue`에 대기 중인 사용자들을 대상으로 "2.1. 단계별 매칭 조건"에 따라 상대를 탐색하여 매칭을 성사시킨다.
3. **데이터베이스 (PostgreSQL)**
    * 모든 매칭 로직의 핵심 두뇌 역할을 한다. `match_queue` 테이블의 레코드에 비관적 락(`FOR UPDATE SKIP LOCKED`)을 설정하여 여러 트랜잭션이 동일한 유저를 동시에 매칭시키는
      것을 방지한다.
4. **실시간 서비스 (Supabase Realtime)**
    * 클라이언트는 `rooms` 테이블의 `INSERT` 이벤트를 구독한다. 매칭이 성사되어 `rooms` 테이블에 레코드가 추가되면, 클라이언트는 즉시 이 사실을 인지하고 다음 화면으로 전환한다.

### 3.3. 미래 확장성 고려

이 아키텍처는 수만 명 단위의 동시 사용자까지 효과적으로 처리할 수 있다. 만약 서비스가 Azar와 같이 초당 수천 건 이상의 매칭 요청을 처리해야 하는 규모로 성장할
경우, [Azar의 Flink 기반 매칭 아키텍처](https://www.ververica.com/blog/data-driven-matchmaking-at-azar-with-apache-flink)와 같은 스트림
처리 모델로의 전환을 고려할 수 있다. Flink 모델은 DB 부하를 최소화하고 진정한 선형 확장이 가능하지만, 시스템 복잡도가 매우 높으므로 신중한 단계적 전환이 필요하다.

## 4. 데이터 모델 [(`ERD.md` 참고)](ERD.md)

## 5. 구현 체크리스트

**Backend (Spring Boot)**

- [ ] `match_queue` 엔티티 및 Repository 생성 (Native Query 필수)
- [ ] MatchService.findMatch() 구현: `FOR UPDATE SKIP LOCKED` 적용 확인
- [ ] MatchScheduler 구현: 1초 주기, 5단계 조건 완화 로직 적용
- [ ] 점수 산정 로직(ScoreService) 구현

**Frontend & Infra**

- [ ] Supabase Realtime 활성화: `rooms` 테이블의 INSERT 이벤트 구독 설정
- [ ] API 연동 (`POST /api/v1/match`, `socket.on('INSERT', 'rooms')`)

**Verification (검증)**

- [ ] **동시성 테스트**: 여러 사용자가 동시에 매칭 시도 시, 중복 매칭이 절대 발생하지 않는지 검증
- [ ] **인덱스 성능 테스트**: `EXPLAIN ANALYZE`를 통해 GIN 인덱스가 정상적으로 사용되며, 1단계 매칭 쿼리가 목표 시간(0.01초) 내에 수행되는지 확인